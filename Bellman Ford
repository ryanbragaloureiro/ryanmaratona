const long long INF = 4e18;
// O(N*M). Preenche dist e parent.
void bellman_ford(int n, int src, vector<int>& U, vector<int>& V, vector<long long>& W, vector<long long>& dist, vector<int>& parent) {
    dist.assign(n, INF); parent.assign(n, -1); dist[src] = 0;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < (int)U.size(); j++) {
            if (dist[U[j]] < INF && dist[U[j]] + W[j] < dist[V[j]]) {
                dist[V[j]] = dist[U[j]] + W[j];
                parent[V[j]] = U[j];
            }
        }
    }
}

vector<int> restore_path(int src, int dest, vector<int>& parent, vector<long long>& dist) {
    vector<int> path;
    if (dist[dest] == INF) return path;
    for (int v = dest; v != -1; v = parent[v]) path.push_back(v);
    reverse(path.begin(), path.end());
    return path;
}

// Deve ser chamado APOS bellman_ford. Retorna o ciclo se houver.
vector<int> find_negative_cycle(int n, vector<int>& U, vector<int>& V, vector<long long>& W, vector<long long>& dist, vector<int>& parent) {
    int x = -1;
    for (int j = 0; j < (int)U.size(); j++) {
        if (dist[U[j]] < INF && dist[U[j]] + W[j] < dist[V[j]]) {
            dist[V[j]] = dist[U[j]] + W[j];
            parent[V[j]] = U[j];
            x = V[j];
        }
    }
    if (x == -1) return {};
    int y = x;
    for (int i = 0; i < n; i++) y = parent[y];
    vector<int> cycle;
    for (int cur = y;; cur = parent[cur]) {
        cycle.push_back(cur);
        if (cur == y && cycle.size() > 1) break;
    }
    reverse(cycle.begin(), cycle.end());
    return cycle;
}
