const int MOD = 1e9+7;

template<typename T> struct Matrix {
    int r, c; vector<vector<T>> m;
    Matrix(int r, int c, T v = 0) : r(r), c(c), m(r, vector<T>(c, v)) {}
    vector<T>& operator[](int i) { return m[i]; }

    friend Matrix operator*(const Matrix &A, const Matrix &B) {
        Matrix C(A.r, B.c, 0);
        for(int i=0; i<A.r; i++)
            for(int k=0; k<A.c; k++) if(A.m[i][k]) // Otimiza se esparsa
                for(int j=0; j<B.c; j++)
                    C[i][j] = (C[i][j] + A.m[i][k] * B.m[k][j]) % MOD;
        return C;
    }

    friend Matrix operator^(Matrix A, long long e) {
        Matrix res(A.r, A.c);
        for(int i=0; i<A.r; i++) res[i][i] = 1;
        while(e) {
            if(e&1) res = res * A;
            A = A * A; e >>= 1;
        }
        return res;
    }
};

// Exemplo fibbonaci:
using Mat = Matrix<long long>;

long long get_fib(long long n) {
    if (n == 0) return 0;
    
    // 1. Cria a matriz de transição 2x2
    Mat T(2, 2);
    T[0][0] = 1; T[0][1] = 1;
    T[1][0] = 1; T[1][1] = 0;

    // 2. Eleva a potência n
    T = T ^ n;

    // 3. O resultado F(n) está na posição [0][1] (ou [1][0])
    // A matriz resultante tem a forma: | F(n+1)  F(n)   |
    //                                  | F(n)    F(n-1) |
    return T[0][1];
}
